<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Colour Explosion Light Show</title>
    <style>
      body {
        padding: 0;
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>

  <body>
    <canvas id="show-canvas" width="1600" height="800"></canvas>
  </body>
  <script>
    var intervalHandle;
    areaHeight = window.innerHeight;
    areaWidth = window.innerWidth;
    centerOffsetX = 0.3;
    centerOffsetY = 0.6;
    areaCenterX = areaWidth * centerOffsetX;
    areaCenterY = areaHeight * centerOffsetY;
    maxR = Math.sqrt(areaCenterX * areaCenterX + areaCenterY * areaCenterY);

    itemsX = 100;
    itemsY = 40;
    items = itemsX * itemsY;
    bleed = 0.5;
    itemWidth = areaWidth / itemsX;
    itemHeight = areaHeight / itemsY;
    itemWidthB = itemWidth + bleed * 2;
    itemHeightB = itemHeight + bleed * 2;
    frameDelay = 50;
    colorStep = 30;
    frameIndex = 0;
    (() => {
      canv = document.getElementById("show-canvas");
      canv.height = areaHeight;
      canv.width = areaWidth;
      ctx = canv.getContext("2d");
      document.addEventListener("keydown", keyDown);
      nextFrame();
    })();

    function start() {
      intervalHandle = setInterval(nextFrame, frameDelay);
    }

    function pause() {
      if (intervalHandle) {
        clearInterval(intervalHandle);
        intervalHandle = undefined;
      }
    }

    function nextFrame() {
      // clear canvas
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canv.width, canv.height);

      // h = -1 * (((frameIndex * colorStep) / 360) % 1); // How should the colors morph
      h = Math.sin(frameIndex / 20) * 0.5 + Math.sin(frameIndex / 5) * 0.3;

      for (let i = 0; i < itemsX; ++i) {
        for (let j = 0; j < itemsY; ++j) {
          x = i * itemWidth;
          y = j * itemHeight;
          xr = x - areaCenterX;
          yr = y - areaCenterY;
          r = Math.sqrt(xr * xr + yr * yr);
          c = r / maxR;
          // Calculate the color to show
          // c = (i * j) / items; // Spread from the top left corner
          // c = (i * itemsX + j * itemsY) / items; // Waves
          drawRectangle(i, j, (c + h) % 1);
        }
      }
      frameIndex++;
    }

    function drawRectangle(i, j, h) {
      x = itemWidth * i - bleed;
      y = itemHeight * j - bleed;

      ctx.fillStyle = hslStyle(h, 1, 0.5);
      ctx.strokeStyle = "black";
      ctx.fillRect(x, y, itemWidthB, itemHeightB);
    }

    function keyDown(ev) {
      if (ev.key === " ") {
        if (intervalHandle) {
          pause();
        } else {
          start();
        }
      } else {
        if (!intervalHandle) {
          start();
        }
      }
    }
    // // input: h as an angle in [0,360] and s,l in [0,1] - output: r,g,b in [0,1]
    // function hsl2rgb(h, s, l) {
    //   let a = s * Math.min(l, 1 - l);
    //   let f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    //   return [f(0), f(8), f(4)];
    //   // return `rgb(${f(0)},${f(8)},${f(4)})`;
    // }

    /**
     * Converts an HSL color value to RGB. Conversion formula
     * adapted from https://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes h, s, and l are contained in the set [0, 1] and
     * returns r, g, and b in the set [0, 255].
     *
     * @param   {number}  h       The hue
     * @param   {number}  s       The saturation
     * @param   {number}  l       The lightness
     * @return  {Array}           The RGB representation
     */
    function hslToRgb(h, s, l) {
      let r, g, b;

      if (s === 0) {
        r = g = b = l; // achromatic
      } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hueToRgb(p, q, h + 1 / 3);
        g = hueToRgb(p, q, h);
        b = hueToRgb(p, q, h - 1 / 3);
      }

      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function hueToRgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }

    /**
     * Write a hsl value in a way that can be used as a canvas fill style
     * Assumes h, s, and l are contained in the set [0, 1] and
     * returns style text.
     *
     * @param   {number}  h       The hue
     * @param   {number}  s       The saturation
     * @param   {number}  l       The lightness
     * @return  {string}          The style representation
     */
    function hslStyle(h, s, l) {
      const colors = hslToRgb(h, s, l);
      return `rgb(${colors[0]},${colors[1]},${colors[2]})`;
    }
  </script>
</html>
