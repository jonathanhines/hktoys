<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fireworks</title>
    <style>
      body {
        padding: 0;
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>

  <body>
    <canvas id="show-canvas" width="1600" height="800"></canvas>
  </body>
  <script>
    var intervalHandle;
    areaHeight = window.innerHeight;
    areaWidth = window.innerWidth;
    areaCenterX = areaWidth / 2;
    areaCenterY = areaHeight / 2;

    frameDelay = 50;
    colorStep = 30;
    frameIndex = 0;

    fireworks = [];

    fireworkPrimaryRadius = 5;
    fireworkSecondaryRadius = 3;
    gravity = 5;
    primaryExplosionPieces = 30;
    secondaryExplosionPieces = 5;
    shellsPerLaunch = 3;
    secondaryStart = 7;
    secondaryExtraStartMax = 10;
    burnOutStart = 10;
    burnOutLength = 5;
    maxInitialPrimaryVelocity = 40;
    maxInitialSecondaryVelocity = 120;
    shellV = -20;
    fireworkLuminosity = 0.8;
    fireworkSaturation = 1;

    // Cached values
    burnOutEnd = burnOutStart + burnOutLength;

    class Firework {
      constructor(r, x, y, vx, vy, color, secondaryDelay, launchSecondary) {
        this.r = r;
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.alpha = 1;
        this.burnOutIndex = 0;
        this.secondaryDelay = secondaryDelay;
        this.launchSecondary = launchSecondary;
      }

      advanceAndRender() {
        if (this.alpha <= 0) {
          return;
        }
        this.vy += gravity;
        this.y += this.vy;

        this.x += this.vx;

        if (this.burnOutIndex >= burnOutEnd) {
          this.alpha = 0;
        } else if (this.burnOutIndex > burnOutStart) {
          this.alpha = 1 - (this.burnOutIndex - burnOutStart) / burnOutLength;
        }

        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.alpha;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI, false);
        ctx.fill();
        ctx.globalAlpha = 1;

        if (this.launchSecondary && this.burnOutIndex === this.secondaryDelay) {
          this.launchSecondary(this);
        }

        this.burnOutIndex++;
      }

      kill() {
        this.alpha = 0;
      }
    }

    (() => {
      canv = document.getElementById("show-canvas");
      canv.height = areaHeight;
      canv.width = areaWidth;
      ctx = canv.getContext("2d");
      document.addEventListener("keydown", keyDown);
    })();

    function start() {
      intervalHandle = setInterval(nextFrame, frameDelay);
    }
    function launchFirework() {
      x = Math.random() * areaWidth;
      y = (Math.random() * areaHeight) / 2;
      var pc = hslStyle(Math.random(), fireworkSaturation, fireworkLuminosity);
      var sc = hslStyle(Math.random(), fireworkSaturation, fireworkLuminosity);
      for (let i = 0; i < primaryExplosionPieces; ++i) {
        pv = Math.random() * maxInitialPrimaryVelocity;
        pa = Math.random() * 2 * Math.PI;
        fireworks.push(
          new Firework(
            fireworkPrimaryRadius,
            x,
            y,
            pv * Math.sin(pa),
            shellV + pv * Math.cos(pa),
            pc,
            secondaryStart + Math.round(Math.random() * secondaryExtraStartMax),
            (parentShell) => {
              for (let j = 0; j < secondaryExplosionPieces; ++j) {
                sv = Math.random() * maxInitialSecondaryVelocity;
                sa = Math.random() * 2 * Math.PI;
                fireworks.push(
                  new Firework(
                    fireworkSecondaryRadius,
                    parentShell.x,
                    parentShell.y,
                    parentShell.vx + sv * Math.sin(sa),
                    parentShell.vy + sv * Math.cos(sa),
                    sc
                  )
                );
              }
              parentShell.kill();
            }
          )
        );
      }
    }

    function pause() {
      if (intervalHandle) {
        clearInterval(intervalHandle);
        intervalHandle = undefined;
      }
    }

    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canv.width, canv.height);
    function nextFrame() {
      console.log(fireworks);
      // clear canvas
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canv.width, canv.height);

      fireworks = fireworks.filter((firework) => firework.alpha > 0);
      fireworks.forEach((firework) => {
        firework.advanceAndRender();
      });
      frameIndex++;
    }

    function keyDown(ev) {
      if (ev.key === " ") {
        if (!intervalHandle) {
          start();
        }
        for (let i = 0; i < shellsPerLaunch; ++i) {
          launchFirework();
        }
      } else {
        if (!intervalHandle) {
          start();
        }
      }
    }

    /**
     * Converts an HSL color value to RGB. Conversion formula
     * adapted from https://en.wikipedia.org/wiki/HSL_color_space.
     * Assumes h, s, and l are contained in the set [0, 1] and
     * returns r, g, and b in the set [0, 255].
     *
     * @param   {number}  h       The hue
     * @param   {number}  s       The saturation
     * @param   {number}  l       The lightness
     * @return  {Array}           The RGB representation
     */
    function hslToRgb(h, s, l) {
      let r, g, b;

      if (s === 0) {
        r = g = b = l; // achromatic
      } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hueToRgb(p, q, h + 1 / 3);
        g = hueToRgb(p, q, h);
        b = hueToRgb(p, q, h - 1 / 3);
      }

      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function hueToRgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }

    /**
     * Write a hsl value in a way that can be used as a canvas fill style
     * Assumes h, s, and l are contained in the set [0, 1] and
     * returns style text.
     *
     * @param   {number}  h       The hue
     * @param   {number}  s       The saturation
     * @param   {number}  l       The lightness
     * @return  {string}          The style representation
     */
    function hslStyle(h, s, l) {
      const colors = hslToRgb(h, s, l);
      return `rgb(${colors[0]},${colors[1]},${colors[2]})`;
    }
  </script>
</html>
